
#' Fetch data from Bismark BAM file
#' 
#' This function retrieves fragments for regions in \code{granges} from BAM file produced by Bismark and parses \code{XM} tags
#' to get protection states of \code{GCH} as well as methylation states of \code{WCG} and \code{bisC}.
#'
#' @param bamfile path to BAM file generated by Bismark.
#' @param granges \code{GRanges} object which specifies regions of interest.
#' @param genome_dnastring \code{DNAStringSet} object with a genome which was used for alignment.
#' If you have 'fasta' file then create this object with function \code{\link[Biostrings]{readDNAStringSet}}.
#' @param bam_index path to index of a bamfile without '.bai' at the end.
#' @param paired_bam type of a library, e.g. fr, rf, ff or single end. Currently SE libraries are not supported.
#'
#' @return
#' @export
#' 
#'

fetch_data_from_bismark_bam <- function(bamfile,
                                        granges,
                                        genome_dnastring,
                                        bam_index = bamfile,
                                        paired_bam = c("fr","ff","rf","no")
                                        ){
  
  required_packages <- c("Rsamtools","GenomicAlignments","Biostrings","BSgenome")
  
  packrespons <- do.call(c,lapply(required_packages,
                        function(pack){
                          if(!requireNamespace(pack, quietly = TRUE)){
                            return("Package '",pack,"' is not installed. It is required for this function.\n")
                          }
                          NULL
                        }))
  
  if(!is.null(packrespons)){
    stop(packrespons)
  }
  
  stopifnot(file.exists(bamfile))
  paired_bam <- match.arg(paired_bam)
  
  if(paired_bam == "no"){
    stop("Sorry the function for SE data is not implemented yet.")
  }
  
  ## create param object
  param <- Rsamtools::ScanBamParam(flag = Rsamtools::scanBamFlag(isDuplicate = FALSE,
                                                                 isNotPassingQualityControls = FALSE),
                                   what = c("qname","rname","cigar"),
                                   which = granges,
                                   tag = "XM")
  
  ## select strandmode
  if(paired_bam %in% c("fr","ff")){
    strandMode <- 1
  } else if(paired_bam %in% c("rf")){
    strandMode <- 2
  } else {
    stop(paste0("Unkown paired_bam value ",paired_bam))
  }
  ## load alignments
  
  galns <- GenomicAlignments::readGAlignmentPairs(file = bamfile,
                                                  param = param,
                                                  use.names = TRUE,
                                                  strandMode = strandMode)
  
  ## extract and parse bismark XM tags
  ## GAlignment for R1 and R2
  r1.ga <- GenomicAlignments::first(galns)
  r2.ga <- GenomicAlignments::last(galns)
  
  ## remove soft clipping from XM tag so that XM tag width matches r1.ga and r2.ga width
  S4Vectors::elementMetadata(r1.ga)$XM <- Biostrings::BStringSet(S4Vectors::elementMetadata(r1.ga)$XM)
  names(S4Vectors::elementMetadata(r1.ga)$XM)  <- S4Vectors::elementMetadata(r1.ga)$qname
  
  S4Vectors::elementMetadata(r2.ga)$XM <- Biostrings::BStringSet(S4Vectors::elementMetadata(r2.ga)$XM)
  names(S4Vectors::elementMetadata(r2.ga)$XM)  <- S4Vectors::elementMetadata(r2.ga)$qname
  
  ## remove soft clipped positions
  S4Vectors::elementMetadata(r1.ga)$XM <- unlist(Biostrings::extractAt(x = S4Vectors::elementMetadata(r1.ga)$XM,
                                                at = GenomicAlignments::cigarRangesAlongQuerySpace(GenomicAlignments::cigar(r1.ga),
                                                                                ops = setdiff(GenomicAlignments::CIGAR_OPS,"S"),
                                                                                drop.empty.ranges = TRUE,
                                                                                reduce.ranges = TRUE)))
  
  S4Vectors::elementMetadata(r2.ga)$XM <- unlist(Biostrings::extractAt(x = S4Vectors::elementMetadata(r2.ga)$XM,
                                                at = GenomicAlignments::cigarRangesAlongQuerySpace(GenomicAlignments::cigar(r2.ga),
                                                                                ops = setdiff(GenomicAlignments::CIGAR_OPS,"S"),
                                                                                drop.empty.ranges = TRUE,
                                                                                reduce.ranges = TRUE)))
  
  ## remove soft clipping from cigar
  r1.ga@cigar <- gsub("^\\d+S|\\d+S$","",GenomicAlignments::cigar(r1.ga),perl=T)
  r2.ga@cigar <- gsub("^\\d+S|\\d+S$","",GenomicAlignments::cigar(r2.ga),perl=T)
  
  ## for Bismark meth and unmeth alphabet find positions in XM tag
  ## Bismark codes
  # z - C in CpG context - unmethylated
  # Z - C in CpG context - methylated
  # x - C in CHG context - unmethylated
  # X - C in CHG context - methylated
  # h - C in CHH context - unmethylated
  # H - C in CHH context - methylated
  # u - C in Unknown context (CN or CHN) - unmethylated
  # U - C in Unknown context (CN or CHN) - methylated
  # . - not a C or irrelevant position
  
  bismark_alphabet_unmeth <- c("z","x","h","u")
  bismark_alphabet_meth <- toupper(bismark_alphabet_unmeth)
  
  ## function for finding positions in XM tag
  match_against_XM <- function(patterns,
                               galignment){
    stopifnot(inherits(S4Vectors::elementMetadata(galignment)$XM,"BStringSet"))
    query_pos <- do.call(pc,lapply(patterns,
                                   function(pat){
                                     Biostrings::vmatchPattern(pattern = pat,
                                                               subject = S4Vectors::elementMetadata(galignment)$XM,
                                                               fixed=TRUE)
                                   }))
    
    ## convert to GRanges
    query_pos <- GenomicRanges::makeGRangesListFromFeatureFragments(seqnames = names(query_pos),
                                                                    fragmentStarts = start(query_pos),
                                                                    fragmentEnds = end(query_pos),
                                                                    strand = strand(galignment))
    query_pos <- unlist(query_pos)
    names(query_pos) <- seqnames(query_pos)
    
    return(query_pos)
  }
  
  ##### positions of Cs in R1 ######
  
  r1_unmeth_query_pos <- match_against_XM(bismark_alphabet_unmeth,
                                          galignment = r1.ga)
  r1_meth_query_pos <- match_against_XM(bismark_alphabet_meth,
                                        galignment = r1.ga)
  
  ##### positions in R2
  r2_unmeth_query_pos <- match_against_XM(bismark_alphabet_unmeth,
                                          galignment = r2.ga)
  r2_meth_query_pos <- match_against_XM(bismark_alphabet_meth,
                                        galignment = r2.ga)
  
  
  #### map positions from query to reference
  
  if(length(r1_unmeth_query_pos) > 0){
    r1_unmeth_ref_pos <- GenomicAlignments::mapFromAlignments(x = r1_unmeth_query_pos,
                                                              alignments = r1.ga)
    strand(r1_unmeth_ref_pos) <- GenomicAlignments::strand(galns[r1_unmeth_ref_pos$alignmentsHits])
    r1_unmeth_ref_pos$meth <- 0
    r1_unmeth_ref_pos$mate <- 1
  } else {
    r1_unmeth_ref_pos <- NULL
  }
  
  if(length(r1_meth_query_pos) > 0){
    r1_meth_ref_pos <- GenomicAlignments::mapFromAlignments(x = r1_meth_query_pos,
                                                            alignments = r1.ga)
    strand(r1_meth_ref_pos) <- GenomicAlignments::strand(galns[r1_meth_ref_pos$alignmentsHits])
    r1_meth_ref_pos$meth <- 1
    r1_meth_ref_pos$mate <- 1
  } else{
    r1_meth_ref_pos <- NULL
  }
  
  if(length(r2_unmeth_query_pos) > 0){
    r2_unmeth_ref_pos <- GenomicAlignments::mapFromAlignments(x = r2_unmeth_query_pos,
                                                              alignments = r2.ga)
    strand(r2_unmeth_ref_pos) <- GenomicAlignments::strand(galns[r2_unmeth_ref_pos$alignmentsHits])
    r2_unmeth_ref_pos$meth <- 0
    r2_unmeth_ref_pos$mate <- 2
  } else {
    r2_unmeth_ref_pos <- NULL
  }
  
  if(length(r2_meth_query_pos) > 0){
    r2_meth_ref_pos <- GenomicAlignments::mapFromAlignments(x = r2_meth_query_pos,
                                                            alignments = r2.ga)
    strand(r2_meth_ref_pos) <- GenomicAlignments::strand(galns[r2_meth_ref_pos$alignmentsHits])
    r2_meth_ref_pos$meth <- 1
    r2_meth_ref_pos$mate <- 2
  } else{
    r2_meth_ref_pos <- NULL
  }
  
  ### combine R1 and R2
  ref_pos <- c(r1_unmeth_ref_pos,
               r1_meth_ref_pos,
               r2_unmeth_ref_pos,
               r2_meth_ref_pos)
  ref_pos$qname <- names(ref_pos)
  names(ref_pos) <- NULL
  
  ## remove data on R2 which overlap with R1 to prevent double counting of same positions
  ref_pos <- GenomicRanges::split(ref_pos,
                                  ref_pos$qname)
  ref_pos <- ref_pos[!GenomicRanges::duplicated(ref_pos)] ## duplicated in this case is fine because strand of r1 and r2 is identical and is strand(gaPairs)
  ref_pos <- unlist(ref_pos,
                    use.names = F)
  
  ### get 3 nucl contexts. note that getSeq returns reverse complement for Granges on "-" strand
  ref_pos$C_cont <- BSgenome::getSeq(x = genome_dnastring,
                                     GenomicRanges::resize(ref_pos,width=3,fix="center"))
  ref_pos <- GenomicRanges::sort(ref_pos,ignore.strand = T)
  
  
  
  
  
  ## get lists of C positions with different context
  
  dataGranges <- GenomicAlignments::granges(galns)
  ref_pos$pos_in_rle <- GenomicRanges::start(ref_pos) - 
    GenomicRanges::start(dataGranges[match(ref_pos$qname,names(dataGranges))]) + 1
  

  ## construct RleLists
  get_rleList <- function(frag_gr,
                          cMethgr,
                          patterns,
                          return_protection = FALSE){
    ## find patterns to include
    
    patcounts <- Reduce("+",mapply(FUN = Biostrings::vcountPattern,
                        pattern = patterns,
                        MoreArgs = list(subject = cMethgr$C_cont,
                                        fixed = FALSE),
                        SIMPLIFY = FALSE,USE.NAMES = TRUE))
    
    cMethgr <- cMethgr[patcounts > 0]
    
    if(return_protection)
      cMethgr$meth <- 1 - cMethgr$meth
    patt_pos <- S4Vectors::split(cMethgr$pos_in_rle,
                                f = cMethgr$qname)
    patt_meth <- S4Vectors::split(cMethgr$meth,
                                 f = cMethgr$qname)
    
    ## construct RleList
    patt_RleList <- IRanges::RleList(lapply(names(frag_gr),
                                                function(rname){
                                                  
                                                  vec <- Rle(values = 2,
                                                             lengths = width(frag_gr[rname]))
                                                  ## set meth
                                                  if(!is.null(patt_pos[[rname]])){
                                                    vec[patt_pos[[rname]]] <- patt_meth[[rname]]
                                                  }
                                                  
                                                  return(vec)
                                                  
                                                }))
    return(patt_RleList)
    
  }
  
  ## GCH and WCG
  gch_RleList <- get_rleList(frag_gr = dataGranges,
                             cMethgr = ref_pos,
                             patterns = "GCH",
                             return_protection = TRUE)
  wcg_RleList <- get_rleList(frag_gr = dataGranges,
                             cMethgr = ref_pos,
                             patterns = "WCG")
  ## get positions which we use for inference of bisulfite efficiency
  ## total 16 combinations of NCN
  ## excluded for bisC
  # a <- c("ACG","CCG","GCG","TCG", ## exclude CpGs
  #   "GCA","GCC","GCG","GCT", ## exclude GpCs
  #   "CCT","CCC","CCA" ## other comb
  # )
  ## allowed combs
  bisC_allowed <- c("ACA", "ACC", "ACT", "TCA", "TCC", "TCT")
  bisC_RleList <- get_rleList(frag_gr = dataGranges,
                             cMethgr = ref_pos,
                             patterns = bisC_allowed)
  
  ## calculate bisC efficiency
  isBisConv <- Rle(sapply(bisC_RleList,
                      function(rle_vec){
                        
                        rle_vec <- rle_vec[rle_vec != 2]
                        if(length(rle_vec) < 5){
                          return(TRUE)
                        } else{
                          if(mean(rle_vec) >= 0.1)
                            return(FALSE)
                          else
                            return(TRUE)
                        }
                      },simplify = TRUE,USE.NAMES = FALSE))

  ## get isUnique
  allC_prof <- get_rleList(frag_gr = dataGranges,
                           cMethgr = ref_pos,
                           patterns = "N")
  allC_prof <- sapply(allC_prof,paste0,collapse = "")
  
  isUnique <- Rle(!(duplicated(dataGranges) | duplicated(allC_prof)))
  
  metDat <- S4Vectors::DataFrame("GCH" = gch_RleList,
                                 "WCG" = wcg_RleList,
                                 "bisC" = bisC_RleList,
                                 "isUnique" = isUnique,
                                 "isBisConv" = isBisConv)
  mcols(dataGranges) <- metDat
  return(dataGranges)
}